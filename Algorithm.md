# 정렬 알고리즘
## 안정 정렬(Stable) vs 불안정 정렬(Unstable)
* 안정 정렬
  * 정렬할 요소 중에서 중복된 값의 위치가 정렬되기 전, 후로 동일한 정렬 알고리즘
  * 중복된 요소가 있어도 항상 동일한 결과를 보이는 장점이 있다.
  * 삽입 정렬, 병합 정렬, 버블 정렬
* 불안정 정렬
  * 정렬할 요소 중에서 중복된 값의 위치가 정렬되기 전, 후로 다른 정렬 알고리즘
  * 퀵정렬, 선택 정렬, 계수 정렬

## In-place 정렬
* 정렬 시 추가적인 메모리 공간이 거의 필요하지 않는 정렬 알고리즘
* In-place 정렬
  * 삽입 정렬
  * 선택 정렬
  * 버블 정렬
  * 셸 정렬
  * 힙 정렬
  * 퀵 정렬
* Not In-place 정렬
  * 병합 정렬
  * 카운트 정렬 
  * 기수 정렬
  * 버킷 정렬

## 분할-정복(Devide-Conquer)
* 현재 주어진 문제를 여러개의 작은 문제로 나누어 해결한 다음 결과를 종합하여 전체 문제를 푸는 방법

## 거품 정렬
* 처음부터 끝까지 순차적으로 현재와 다음 요소와 비교하여 정렬하는 알고리즘
* 1회전이 끝날 때마다 가장 큰 요소가 맨 뒤로 가게 되고, 해당 요소는 제외된다.
* 교환(swap) 연산이 많이 발생한다.
* in-place, stable 정렬이다.
* 시간 복잡도
 * 최선 : O(n^2)
 * 평균 : O(n^2)
 * 최악 : O(n^2)
* 공간 복잡도
 * O(n)

## 선택 정렬
* 배열의 위치를 미리 정하고, 해당 위치에 올 요소를 선택하여 정렬하는 알고리즘
* 정렬되지 않은 부분에서 최소값을 찾고 맨 앞의 요소와 교체 후 제외한다.
* in-place, unstable 정렬
* 시간 복잡도
 * 최선 : O(n^2)
 * 평균 : O(n^2)
 * 최악 : O(n^2)
* 공간 복잡도
 * O(n)

## 삽입 정렬
* 2번째 요소부터 시작해서 정렬된 부분인 현재 요소 앞에서 시작하여 삽입할 위치를 찾고, 뒷 부분 요소들을 한칸씩 뒤로 옮겨 자리를 만들어 삽입해 정렬하는 알고리즘
* 거의 정렬되어 있는 요소들을 정렬할 때 효율적이다. -> O(n)
* 선택 정렬과 달리 필요한 부분(현재 요소 앞에서부터 자신보다 큰 값들만 비교함)만 탐색한다.
* in-place, stable 정렬
* 시간 복잡도
 * 최선 : O(n)
 * 평균 : O(n^2)
 * 최악 : O(n^2)
* 공간 복잡도
 * O(n)

## 퀵 정렬
* 분할 정복을 사용하는 정렬 알고리즘
* 현재 요소 중에서 기준이 될 요소(pivot)를 정한 뒤, pivot을 기준으로 앞에는 pivot보다 작은 값들이 위치하도록, 뒤에는 pivot보다 큰 값들이 위치하도록 한다. (분할, Devide)
* 분할된 두 요소를 재귀적으로 앞의 과정을 거쳐서 정렬시킨다.
* 재귀가 한번 호출될 때 마다, 최소 한 개 pivot의 위치가 정해지므로 알고리즘이 무조건 끝나는 것을 보장한다.
* pivot에 따라 균등하지 않는 크기로 분할될 수 있다.
* pivot값이 최소, 최대일 경우 O(n^2)이 걸린다.
* in-place, unstable 정렬
* 시간 복잡도
 * 최선 : O(nlogn)
 * 평균 : O(nlogn)
 * 최악 : O(n^2) -> 정렬할 배열이 오름차순 또는 내림차순일 경우
* 공간 복잡도
 * O(n)

## 병합 정렬
* 분할 정복을 사용하는 정렬 알고리즘
* 배열의 크기가 1일 때까지 반으로 분할한 다음, 분할된 배열을 합치면서 정렬하는 알고리즘
* 합쳐질 두 배열들은 이미 정렬된 상태이므로, 두 배열을 순차적으로 비교해 하나로 합칠 수 있다.
* Linked-List를 정렬할 때 효율적이다.(합칠 두 배열을 순차적으로 비교해 하나로 합치기 때문)
* not in-place 정렬, stable 정렬
* 시간 복잡도
 * 최선 : O(nlogn)
 * 평균 : O(nlogn)
 * 최악 : O(nlogn)
* 공간 복잡도
 * O(n)

## 힙 정렬
* 힙을 이용해 정렬하는 알고리즘
* in-place, unstable 정렬
* heapify 과정을 거쳐서 정렬을 위한 힙을 만든다.
* 힙을 
* 시간 복잡도
 * 최선 : O(nlogn)
 * 평균 : O(nlogn)
 * 최악 : O(nlogn)

## 


















